package com.droaemon.common.util;

import org.junit.Test;

import java.nio.charset.StandardCharsets;

public class AesUtilTest {

    byte[] mockKey = {
        (byte) 0x61, (byte) 0x61, (byte) 0x61, (byte) 0x61,
        (byte) 0x61, (byte) 0x61, (byte) 0x61, (byte) 0x61,
        (byte) 0x61, (byte) 0x61, (byte) 0x61, (byte) 0x61,
        (byte) 0x61, (byte) 0x61, (byte) 0x61, (byte) 0x61,
        (byte) 0x8e, (byte) 0x8e, (byte) 0x8e, (byte) 0x8f,
        (byte) 0xef, (byte) 0xef, (byte) 0xef, (byte) 0xee,
        (byte) 0x8e, (byte) 0x8e, (byte) 0x8e, (byte) 0x8f,
        (byte) 0xef, (byte) 0xef, (byte) 0xef, (byte) 0xee,
        (byte) 0xa6, (byte) 0x51, (byte) 0x51, (byte) 0x52,
        (byte) 0x49, (byte) 0xbe, (byte) 0xbe, (byte) 0xbc,

        (byte) 0xc7, (byte) 0x30, (byte) 0x30, (byte) 0x33,
        (byte) 0x28, (byte) 0xdf, (byte) 0xdf, (byte) 0xdd,
        (byte) 0x67, (byte) 0x65, (byte) 0xcf, (byte) 0xc8,
        (byte) 0x2e, (byte) 0xdb, (byte) 0x71, (byte) 0x74,
        (byte) 0xe9, (byte) 0xeb, (byte) 0x41, (byte) 0x47,
        (byte) 0xc1, (byte) 0x34, (byte) 0x9e, (byte) 0x9a,
        (byte) 0xdf, (byte) 0x1d, (byte) 0xd7, (byte) 0xcb,
        (byte) 0xf1, (byte) 0xc6, (byte) 0xa6, (byte) 0xbf,
        (byte) 0x18, (byte) 0x2d, (byte) 0xe7, (byte) 0xf8,
        (byte) 0xd9, (byte) 0x19, (byte) 0x79, (byte) 0x62,

        (byte) 0x75, (byte) 0x28, (byte) 0x03, (byte) 0x6d,
        (byte) 0x84, (byte) 0xee, (byte) 0xa5, (byte) 0xd2,
        (byte) 0x9c, (byte) 0xc3, (byte) 0x42, (byte) 0x2a,
        (byte) 0x45, (byte) 0xda, (byte) 0x3b, (byte) 0x48,
        (byte) 0x27, (byte) 0x46, (byte) 0x54, (byte) 0xaf,
        (byte) 0xa3, (byte) 0xa8, (byte) 0xf1, (byte) 0x7d,
        (byte) 0x3f, (byte) 0x6b, (byte) 0xb3, (byte) 0x57,
        (byte) 0x7a, (byte) 0xb1, (byte) 0x88, (byte) 0x1f,
        (byte) 0xe7, (byte) 0x9c, (byte) 0x9c, (byte) 0x2b,
        (byte) 0x44, (byte) 0x34, (byte) 0x6d, (byte) 0x56,

        (byte) 0x7b, (byte) 0x5f, (byte) 0xde, (byte) 0x01,
        (byte) 0x01, (byte) 0xee, (byte) 0x56, (byte) 0x1e,
        (byte) 0x95, (byte) 0xe0, (byte) 0xb4, (byte) 0x1a,
        (byte) 0xd1, (byte) 0xd4, (byte) 0xd9, (byte) 0x4c,
        (byte) 0xaa, (byte) 0x8b, (byte) 0x07, (byte) 0x4d,
        (byte) 0xab, (byte) 0x65, (byte) 0x51, (byte) 0x53,
        (byte) 0x78, (byte) 0x82, (byte) 0xf9, (byte) 0xd0,
        (byte) 0xa9, (byte) 0x56, (byte) 0x20, (byte) 0x9c,
        (byte) 0x03, (byte) 0xdd, (byte) 0x27, (byte) 0xd1,
        (byte) 0xa8, (byte) 0xb8, (byte) 0x76, (byte) 0x82,

        (byte) 0x6b, (byte) 0x40, (byte) 0x95, (byte) 0xde,
        (byte) 0xc2, (byte) 0x16, (byte) 0xb5, (byte) 0x42,
        (byte) 0xc1, (byte) 0xcb, (byte) 0x92, (byte) 0x93,
        (byte) 0x69, (byte) 0x73, (byte) 0xe4, (byte) 0x11,
        (byte) 0x40, (byte) 0xf0, (byte) 0xbf, (byte) 0xef,
        (byte) 0xfe, (byte) 0x7f, (byte) 0x00, (byte) 0x00,
        (byte) 0xf2, (byte) 0x18, (byte) 0x00, (byte) 0x00,
        (byte) 0x01, (byte) 0x00, (byte) 0x00, (byte) 0x00,
        (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
        (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,

        (byte) 0x91, (byte) 0x00, (byte) 0x91, (byte) 0xc2,
        (byte) 0x40, (byte) 0x06, (byte) 0x00, (byte) 0x00,
        (byte) 0xb0, (byte) 0x02, (byte) 0x00, (byte) 0x00,
        (byte) 0x14, (byte) 0x00, (byte) 0x00, (byte) 0x00,
        (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
        (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
        (byte) 0x20, (byte) 0x00, (byte) 0x00, (byte) 0x00,
        (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
        (byte) 0x08, (byte) 0x00, (byte) 0x00, (byte) 0x00,
        (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,

    };

    @Test
    public void encrypt() {
//        byte[] iv = genIv(16);
        String iv = "bbbbbbbbbbbbbbbb";
        String content = "1407af3a613f328a59661f31cdb54609";
//        String key = "d20$?Z$$$Q?-Q-Q-6Q$QQQQQQQQ6Q6Q6";
        String key = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
        String result = AesUtil.encrypt(content, key.getBytes(), iv.getBytes());
        System.out.println(result);
    }

    private byte[] genIv(int length) {
        byte seed = (byte) 128;
        byte[] result = new byte[length];
        for (int i = 0; i < length; i++) {
            byte temp = (byte) (seed / 2);
            result[i] = temp;
            seed = (byte) (i * i);
        }

        return result;
    }

//    private int[] aesKeySetup(byte[] key, int length) {
//        int Nb = 4;
//        int Nr;
//        int Nk;
//        int idx;
//        int[] w = new int[60];
//
//        int temp;
//        int[] Rcon = {0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000,
//            0x40000000, 0x80000000, 0x1b000000, 0x36000000, 0x6c000000, 0xd8000000,
//            0xab000000, 0x4d000000, 0x9a000000};
//
//        switch (length) {
//            case 128:
//                Nr = 10;
//                Nk = 4;
//                break;
//
//            case 192:
//                Nr = 12;
//                Nk = 6;
//                break;
//
//            case 256:
//                Nr = 14;
//                Nk = 8;
//                break;
//
//            default:
//                throw new IllegalArgumentException();
//        }
//
//        for (idx = 0; idx < Nk; ++idx) {
//            w[idx] = ((key[4 * idx]) << 24) | ((key[4 * idx + 1]) << 16) |
//                ((key[4 * idx + 2]) << 8) | ((key[4 * idx + 3]));
//        }
//
//        for (idx = Nk; idx < Nb * (Nr + 1); ++idx) {
//            temp = w[idx - 1];
//            if ((idx % Nk) == 0)
//                temp = SubWord(KE_ROTWORD(temp)) ^ Rcon[(idx - 1) / Nk];
//            else if (Nk > 6 && (idx % Nk) == 4)
//                temp = SubWord(temp);
//            w[idx] = w[idx - Nk] ^ temp;
//        }
//    }

    // Substitutes a word using the AES S-Box.
    int SubWord(int word) {
        int result;

        result = (int) aes_sbox[(word >> 4) & 0x0000000F][word & 0x0000000F];
        result += (int) aes_sbox[(word >> 12) & 0x0000000F][(word >> 8) & 0x0000000F] << 8;
        result += (int) aes_sbox[(word >> 20) & 0x0000000F][(word >> 16) & 0x0000000F] << 16;
        result += (int) aes_sbox[(word >> 28) & 0x0000000F][(word >> 24) & 0x0000000F] << 24;
        return (result);
    }

    static char[][] aes_sbox = {
        {0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76},
        {0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0},
        {0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15},
        {0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75},
        {0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84},
        {0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF},
        {0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8},
        {0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2},
        {0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73},
        {0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB},
        {0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79},
        {0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08},
        {0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A},
        {0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E},
        {0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF},
        {0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16}
    };
}
